{
  "name": "depth-first-search",
  "dependencies": [],
  "files": [
    {
      "name": "depth-first-search.ts",
      "content": "import { useState, useCallback } from 'react';\n\ninterface UseDepthFirstSearchReturn {\n  exploredNodes: string[];\n  path: string[] | null;\n  isProcessing: boolean;\n  startDFS: (\n    graph: Record<string, string[]>,\n    start: string,\n    target?: string,\n    onComplete?: (path: string[] | null) => void\n  ) => void;\n  reset: () => void;\n}\n\nfunction useDepthFirstSearch(): UseDepthFirstSearchReturn {\n  const [exploredNodes, setExploredNodes] = useState<string[]>([]);\n  const [path, setPath] = useState<string[] | null>(null);\n  const [isProcessing, setIsProcessing] = useState<boolean>(false);\n\n  // DFS algorithm implementation\n  const dfs = useCallback(\n    (graph: Record<string, string[]>, start: string, target?: string): { exploredNodes: string[]; path: string[] | null } => {\n      const explored = new Set<string>();\n      const resultPath: string[] = [];\n\n      const traverse = (node: string, currentPath: string[]): boolean => {\n        explored.add(node);\n        currentPath.push(node);\n\n        if (node === target) {\n          resultPath.push(...currentPath); // Found the target, copy the current path\n          return true; // Stop further traversal\n        }\n\n        for (const neighbor of graph[node] || []) {\n          if (!explored.has(neighbor)) {\n            if (traverse(neighbor, currentPath)) {\n              return true; // Stop if target is found in a deeper recursion\n            }\n          }\n        }\n\n        currentPath.pop(); // Backtrack\n        return false; // Target not found in this branch\n      };\n\n      traverse(start, []);\n      return { exploredNodes: Array.from(explored), path: resultPath.length > 0 ? resultPath : null };\n    },\n    []\n  );\n\n  // Start DFS traversal\n  const startDFS = useCallback(\n    (graph: Record<string, string[]>, start: string, target?: string, onComplete?: (path: string[] | null) => void) => {\n      if (!graph || typeof graph !== 'object') {\n        throw new Error('Graph must be a valid adjacency list');\n      }\n      if (!graph[start]) {\n        throw new Error('Start node is not in the graph');\n      }\n\n      setIsProcessing(true);\n      const { exploredNodes, path } = dfs(graph, start, target);\n      setExploredNodes(exploredNodes);\n      setPath(path);\n      setIsProcessing(false);\n\n      if (onComplete) onComplete(path);\n    },\n    [dfs]\n  );\n\n  // Reset the state\n  const reset = useCallback(() => {\n    setExploredNodes([]);\n    setPath(null);\n    setIsProcessing(false);\n  }, []);\n\n  return {\n    exploredNodes,\n    path,\n    isProcessing,\n    startDFS,\n    reset,\n  };\n}\n\nexport default useDepthFirstSearch;\n"
    }
  ],
  "type": "hooks:hook"
}