{
  "name": "history-state",
  "dependencies": [],
  "files": [
    {
      "name": "history-state.ts",
      "content": "import * as React from \"react\"\n\ninterface HistoryState<T> {\n  past: T[]\n  present: T | null\n  future: T[]\n}\n\ntype HistoryAction<T> =\n  | { type: \"UNDO\" }\n  | { type: \"REDO\" }\n  | { type: \"SET\"; newPresent: T }\n  | { type: \"CLEAR\"; initialPresent: T }\n\nconst initialUseHistoryStateState = <T>(\n  initialPresent: T\n): HistoryState<T> => ({\n  past: [],\n  present: initialPresent,\n  future: [],\n})\n\nfunction useHistoryStateReducer<T>(\n  state: HistoryState<T>,\n  action: HistoryAction<T>\n): HistoryState<T> {\n  const { past, present, future } = state\n\n  switch (action.type) {\n    case \"UNDO\":\n      if (past.length === 0) return state\n      return {\n        past: past.slice(0, past.length - 1),\n        present: past[past.length - 1] ?? null,\n        future: present !== null ? [present, ...future] : future,\n      }\n    case \"REDO\":\n      if (future.length === 0) return state\n      return {\n        past: present !== null ? [...past, present] : past,\n        present: future[0] ?? null,\n        future: future.slice(1),\n      }\n    case \"SET\":\n      if (action.newPresent === present) return state\n      return {\n        past: present !== null ? [...past, present] : past,\n        present: action.newPresent,\n        future: [],\n      }\n    case \"CLEAR\":\n      return initialUseHistoryStateState(action.initialPresent)\n    default:\n      throw new Error(\"Unsupported action type\")\n  }\n}\n\nexport function useHistoryState<T>(initialPresent: T): {\n  state: T | unknown | null\n  set: (newPresent: T) => void\n  undo: () => void\n  redo: () => void\n  clear: () => void\n  canUndo: boolean\n  canRedo: boolean\n} {\n  const initialPresentRef = React.useRef(initialPresent)\n\n  const [state, dispatch] = React.useReducer(\n    useHistoryStateReducer,\n    initialUseHistoryStateState(initialPresentRef.current)\n  )\n\n  const canUndo = state.past.length !== 0\n  const canRedo = state.future.length !== 0\n\n  const undo = React.useCallback(() => {\n    if (canUndo) {\n      dispatch({ type: \"UNDO\" })\n    }\n  }, [canUndo])\n\n  const redo = React.useCallback(() => {\n    if (canRedo) {\n      dispatch({ type: \"REDO\" })\n    }\n  }, [canRedo])\n\n  const set = React.useCallback(\n    (newPresent: T) => dispatch({ type: \"SET\", newPresent }),\n    []\n  )\n\n  const clear = React.useCallback(\n    () =>\n      dispatch({ type: \"CLEAR\", initialPresent: initialPresentRef.current }),\n    []\n  )\n\n  return { state: state.present, set, undo, redo, clear, canUndo, canRedo }\n}\n"
    }
  ],
  "type": "hooks:hook"
}