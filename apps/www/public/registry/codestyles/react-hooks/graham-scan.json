{
  "name": "graham-scan",
  "dependencies": [],
  "files": [
    {
      "name": "graham-scan.ts",
      "content": "import { useState, useCallback } from 'react';\n\ninterface Point {\n  x: number;\n  y: number;\n}\n\ninterface UseGrahamScanReturn {\n  convexHull: Point[];\n  isProcessing: boolean;\n  startScan: (\n    points: Point[],\n    onComplete?: (hull: Point[]) => void\n  ) => void;\n  reset: () => void;\n}\n\nfunction useGrahamScan(): UseGrahamScanReturn {\n  const [convexHull, setConvexHull] = useState<Point[]>([]);\n  const [isProcessing, setIsProcessing] = useState<boolean>(false);\n\n  const crossProduct = (o: Point, a: Point, b: Point): number => {\n    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n  };\n\n  const polarAngleSort = (points: Point[], start: Point): Point[] => {\n    return points.sort((a, b) => {\n      const cross = crossProduct(start, a, b);\n      if (cross === 0) {\n        // If the points are collinear, sort by distance from the start point\n        const distA = (a.x - start.x) ** 2 + (a.y - start.y) ** 2;\n        const distB = (b.x - start.x) ** 2 + (b.y - start.y) ** 2;\n        return distA - distB;\n      }\n      return cross < 0 ? 1 : -1; // Sort by polar angle\n    });\n  };\n\n  const grahamScan = useCallback((points: Point[]): Point[] => {\n    if (points.length < 3) return points;\n\n    // Step 1: Find the point with the lowest y-coordinate (leftmost in case of tie)\n    const start = points.reduce((lowest, point) =>\n      point.y < lowest.y || (point.y === lowest.y && point.x < lowest.x)\n        ? point\n        : lowest\n    );\n\n    // Step 2: Sort the points by polar angle with the start point\n    const sortedPoints = polarAngleSort(points.filter(p => p !== start), start);\n\n    // Step 3: Initialize the convex hull with the first three points\n    const hull: Point[] = [start, sortedPoints[0], sortedPoints[1]];\n\n    // Step 4: Process the remaining points\n    for (let i = 2; i < sortedPoints.length; i++) {\n      const point = sortedPoints[i];\n      while (\n        hull.length >= 2 &&\n        crossProduct(hull[hull.length - 2], hull[hull.length - 1], point) <= 0\n      ) {\n        hull.pop(); // Remove the last point from the hull\n      }\n      hull.push(point); // Add the current point to the hull\n    }\n\n    return hull;\n  }, []);\n\n  const startScan = useCallback(\n    (points: Point[], onComplete?: (hull: Point[]) => void) => {\n      if (!Array.isArray(points) || points.length < 3) {\n        throw new Error('At least 3 points are required to compute the convex hull');\n      }\n\n      setIsProcessing(true);\n      const hull = grahamScan(points);\n      setConvexHull(hull);\n      setIsProcessing(false);\n\n      if (onComplete) onComplete(hull);\n    },\n    [grahamScan]\n  );\n\n  const reset = useCallback(() => {\n    setConvexHull([]);\n    setIsProcessing(false);\n  }, []);\n\n  return {\n    convexHull,\n    isProcessing,\n    startScan,\n    reset,\n  };\n}\n\nexport default useGrahamScan;\n"
    }
  ],
  "type": "hooks:hook"
}