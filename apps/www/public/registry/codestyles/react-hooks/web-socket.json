{
  "name": "web-socket",
  "dependencies": [],
  "files": [
    {
      "name": "web-socket.ts",
      "content": "import { useEffect, useRef, useState } from 'react';\nimport useLatest from './latest';\nimport useMemoizedFn from './memoized-fn';\nimport useUnmount from './unmount';\n\nexport enum ReadyState {\n  Connecting = 0,\n  Open = 1,\n  Closing = 2,\n  Closed = 3,\n}\n\nexport interface Options {\n  reconnectLimit?: number;\n  reconnectInterval?: number;\n  manual?: boolean;\n  onOpen?: (event: WebSocketEventMap['open'], instance: WebSocket) => void;\n  onClose?: (event: WebSocketEventMap['close'], instance: WebSocket) => void;\n  onMessage?: (message: WebSocketEventMap['message'], instance: WebSocket) => void;\n  onError?: (event: WebSocketEventMap['error'], instance: WebSocket) => void;\n\n  protocols?: string | string[];\n}\n\nexport interface Result {\n  latestMessage?: WebSocketEventMap['message'];\n  sendMessage: WebSocket['send'];\n  disconnect: () => void;\n  connect: () => void;\n  readyState: ReadyState;\n  webSocketIns?: WebSocket;\n}\n\nexport default function useWebSocket(socketUrl: string, options: Options = {}): Result {\n  const {\n    reconnectLimit = 3,\n    reconnectInterval = 3 * 1000,\n    manual = false,\n    onOpen,\n    onClose,\n    onMessage,\n    onError,\n    protocols,\n  } = options;\n\n  const onOpenRef = useLatest(onOpen);\n  const onCloseRef = useLatest(onClose);\n  const onMessageRef = useLatest(onMessage);\n  const onErrorRef = useLatest(onError);\n\n  const reconnectTimesRef = useRef(0);\n  const reconnectTimerRef = useRef<ReturnType<typeof setTimeout>>();\n  const websocketRef = useRef<WebSocket>();\n\n  const [latestMessage, setLatestMessage] = useState<WebSocketEventMap['message']>();\n  const [readyState, setReadyState] = useState<ReadyState>(ReadyState.Closed);\n\n  const reconnect = () => {\n    if (\n      reconnectTimesRef.current < reconnectLimit &&\n      websocketRef.current?.readyState !== ReadyState.Open\n    ) {\n      if (reconnectTimerRef.current) {\n        clearTimeout(reconnectTimerRef.current);\n      }\n\n      reconnectTimerRef.current = setTimeout(() => {\n        connectWs();\n        reconnectTimesRef.current++;\n      }, reconnectInterval);\n    }\n  };\n\n  const connectWs = () => {\n    if (reconnectTimerRef.current) {\n      clearTimeout(reconnectTimerRef.current);\n    }\n\n    if (websocketRef.current) {\n      websocketRef.current.close();\n    }\n\n    const ws = new WebSocket(socketUrl, protocols);\n    setReadyState(ReadyState.Connecting);\n\n    ws.onerror = (event) => {\n      if (websocketRef.current !== ws) {\n        return;\n      }\n      reconnect();\n      onErrorRef.current?.(event, ws);\n      setReadyState(ws.readyState || ReadyState.Closed);\n    };\n    ws.onopen = (event) => {\n      if (websocketRef.current !== ws) {\n        return;\n      }\n      onOpenRef.current?.(event, ws);\n      reconnectTimesRef.current = 0;\n      setReadyState(ws.readyState || ReadyState.Open);\n    };\n    ws.onmessage = (message: WebSocketEventMap['message']) => {\n      if (websocketRef.current !== ws) {\n        return;\n      }\n      onMessageRef.current?.(message, ws);\n      setLatestMessage(message);\n    };\n    ws.onclose = (event) => {\n      onCloseRef.current?.(event, ws);\n      // closed by server\n      if (websocketRef.current === ws) {\n        reconnect();\n      }\n      // closed by disconnect or closed by server\n      if (!websocketRef.current || websocketRef.current === ws) {\n        setReadyState(ws.readyState || ReadyState.Closed);\n      }\n    };\n\n    websocketRef.current = ws;\n  };\n\n  const sendMessage: WebSocket['send'] = (message) => {\n    if (readyState === ReadyState.Open) {\n      websocketRef.current?.send(message);\n    } else {\n      throw new Error('WebSocket disconnected');\n    }\n  };\n\n  const connect = () => {\n    reconnectTimesRef.current = 0;\n    connectWs();\n  };\n\n  const disconnect = () => {\n    if (reconnectTimerRef.current) {\n      clearTimeout(reconnectTimerRef.current);\n    }\n\n    reconnectTimesRef.current = reconnectLimit;\n    websocketRef.current?.close();\n    websocketRef.current = undefined;\n  };\n\n  useEffect(() => {\n    if (!manual && socketUrl) {\n      connect();\n    }\n  }, [socketUrl, manual]);\n\n  useUnmount(() => {\n    disconnect();\n  });\n\n  return {\n    latestMessage,\n    sendMessage: useMemoizedFn(sendMessage),\n    connect: useMemoizedFn(connect),\n    disconnect: useMemoizedFn(disconnect),\n    readyState,\n    webSocketIns: websocketRef.current,\n  };\n}\n"
    },
    {
      "name": "latest.ts",
      "content": "import { useRef } from 'react';\n\nfunction useLatest<T>(value: T) {\n  const ref = useRef(value);\n  ref.current = value;\n\n  return ref;\n}\n\nexport default useLatest;\n"
    },
    {
      "name": "memoized-fn.ts",
      "content": "import { useMemo, useRef } from \"react\"\n\nexport const isFunction = (value: unknown): value is (...args: any) => any =>\n  typeof value === \"function\"\n\nexport const isDev =\n  process.env.NODE_ENV === \"development\" || process.env.NODE_ENV === \"test\"\n\ntype noop = (this: any, ...args: any[]) => any\n\ntype PickFunction<T extends noop> = (\n  this: ThisParameterType<T>,\n  ...args: Parameters<T>\n) => ReturnType<T>\n\nfunction useMemoizedFn<T extends noop>(fn: T) {\n  if (isDev) {\n    if (!isFunction(fn)) {\n      console.error(\n        `useMemoizedFn expected parameter is a function, got ${typeof fn}`\n      )\n    }\n  }\n\n  const fnRef = useRef<T>(fn)\n\n  // why not write `fnRef.current = fn`?\n  fnRef.current = useMemo<T>(() => fn, [fn])\n\n  const memoizedFn = useRef<PickFunction<T>>()\n  if (!memoizedFn.current) {\n    memoizedFn.current = function (this, ...args) {\n      return fnRef.current.apply(this, args)\n    }\n  }\n\n  return memoizedFn.current as T\n}\n\nexport default useMemoizedFn\n"
    },
    {
      "name": "unmount.ts",
      "content": "import { useEffect } from 'react';\nimport useLatest from './latest';\n\nconst isFunction = (value: unknown): value is (...args: any) => any =>\n  typeof value === 'function';\n\nconst isDev = process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test';\n\nconst useUnmount = (fn: () => void) => {\n  if (isDev) {\n    if (!isFunction(fn)) {\n      console.error(`useUnmount expected parameter is a function, got ${typeof fn}`);\n    }\n  }\n\n  const fnRef = useLatest(fn);\n\n  useEffect(\n    () => () => {\n      fnRef.current();\n    },\n    [],\n  );\n};\n\nexport default useUnmount;\n"
    }
  ],
  "type": "hooks:hook"
}