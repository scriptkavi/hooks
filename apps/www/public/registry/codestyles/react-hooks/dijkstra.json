{
  "name": "dijkstra",
  "dependencies": [],
  "files": [
    {
      "name": "dijkstra.ts",
      "content": "import { useState, useCallback } from 'react';\n\ninterface UseDijkstraReturn {\n  shortestPath: string[];\n  distance: number | null;\n  isProcessing: boolean;\n  startDijkstra: (\n    graph: Record<string, Record<string, number>>,\n    start: string,\n    target: string,\n    onComplete?: (path: string[], distance: number | null) => void\n  ) => void;\n  reset: () => void;\n}\n\nfunction useDijkstra(): UseDijkstraReturn {\n  const [shortestPath, setShortestPath] = useState<string[]>([]);\n  const [distance, setDistance] = useState<number | null>(null);\n  const [isProcessing, setIsProcessing] = useState<boolean>(false);\n\n  // Dijkstra algorithm implementation\n  const dijkstra = useCallback(\n    (graph: Record<string, Record<string, number>>, start: string, target: string): { path: string[]; distance: number | null } => {\n      const distances: Record<string, number> = {};\n      const previous: Record<string, string | null> = {};\n      const unvisited = new Set(Object.keys(graph));\n\n      for (const node of unvisited) {\n        distances[node] = Infinity;\n        previous[node] = null;\n      }\n      distances[start] = 0;\n\n      while (unvisited.size > 0) {\n        const currentNode = Array.from(unvisited).reduce((minNode, node) => (distances[node] < distances[minNode] ? node : minNode));\n\n        if (currentNode === target) break;\n        if (distances[currentNode] === Infinity) break;\n\n        unvisited.delete(currentNode);\n\n        for (const neighbor in graph[currentNode]) {\n          const newDistance = distances[currentNode] + graph[currentNode][neighbor];\n          if (newDistance < distances[neighbor]) {\n            distances[neighbor] = newDistance;\n            previous[neighbor] = currentNode;\n          }\n        }\n      }\n\n      const path: string[] = [];\n      let currentNode = target;\n      while (previous[currentNode]) {\n        path.unshift(currentNode);\n        currentNode = previous[currentNode]!;\n      }\n      if (distances[target] === Infinity) {\n        return { path: [], distance: null };\n      }\n      path.unshift(start);\n      return { path, distance: distances[target] };\n    },\n    []\n  );\n\n  // Start Dijkstra's algorithm\n  const startDijkstra = useCallback(\n    (graph: Record<string, Record<string, number>>, start: string, target: string, onComplete?: (path: string[], distance: number | null) => void) => {\n      if (!graph || typeof graph !== 'object') {\n        throw new Error('Graph must be a valid adjacency list object');\n      }\n      if (!graph[start] || !graph[target]) {\n        throw new Error('Start or target node is not in the graph');\n      }\n\n      setIsProcessing(true);\n      const { path, distance } = dijkstra(graph, start, target);\n      setShortestPath(path);\n      setDistance(distance);\n      setIsProcessing(false);\n\n      if (onComplete) onComplete(path, distance);\n    },\n    [dijkstra]\n  );\n\n  // Reset the state\n  const reset = useCallback(() => {\n    setShortestPath([]);\n    setDistance(null);\n    setIsProcessing(false);\n  }, []);\n\n  return {\n    shortestPath,\n    distance,\n    isProcessing,\n    startDijkstra,\n    reset,\n  };\n}\n\nexport default useDijkstra;\n"
    }
  ],
  "type": "hooks:hook"
}