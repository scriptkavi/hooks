{
  "name": "breadth-first-search",
  "dependencies": [],
  "files": [
    {
      "name": "breadth-first-search.ts",
      "content": "import { useState, useCallback } from 'react';\n\ninterface UseBreadthFirstSearchReturn {\n  exploredNodes: string[];\n  path: string[] | null;\n  isProcessing: boolean;\n  startBFS: (\n    graph: Record<string, string[]>,\n    start: string,\n    target?: string,\n    onComplete?: (path: string[] | null) => void\n  ) => void;\n  reset: () => void;\n}\n\nfunction useBreadthFirstSearch(): UseBreadthFirstSearchReturn {\n  const [exploredNodes, setExploredNodes] = useState<string[]>([]);\n  const [path, setPath] = useState<string[] | null>(null);\n  const [isProcessing, setIsProcessing] = useState<boolean>(false);\n\n  // BFS algorithm implementation\n  const bfs = useCallback(\n    (graph: Record<string, string[]>, start: string, target?: string): { exploredNodes: string[]; path: string[] | null } => {\n      const queue: string[][] = [[start]]; // Queue holds paths, not just nodes\n      const explored = new Set<string>();\n      explored.add(start);\n\n      while (queue.length > 0) {\n        const currentPath = queue.shift()!; // Get the first path from the queue\n        const currentNode = currentPath[currentPath.length - 1]; // Last node in the current path\n\n        if (currentNode === target) {\n          return { exploredNodes: Array.from(explored), path: currentPath }; // Return the path if the target is found\n        }\n\n        for (const neighbor of graph[currentNode] || []) {\n          if (!explored.has(neighbor)) {\n            explored.add(neighbor);\n            queue.push([...currentPath, neighbor]); // Add the neighbor to the current path and enqueue it\n          }\n        }\n      }\n\n      return { exploredNodes: Array.from(explored), path: target ? null : [] }; // Return all explored nodes and null if no path to target\n    },\n    []\n  );\n\n  // Start BFS traversal\n  const startBFS = useCallback(\n    (graph: Record<string, string[]>, start: string, target?: string, onComplete?: (path: string[] | null) => void) => {\n      if (!graph || typeof graph !== 'object') {\n        throw new Error('Graph must be a valid adjacency list');\n      }\n      if (!graph[start]) {\n        throw new Error('Start node is not in the graph');\n      }\n\n      setIsProcessing(true);\n      const { exploredNodes, path } = bfs(graph, start, target);\n      setExploredNodes(exploredNodes);\n      setPath(path);\n      setIsProcessing(false);\n\n      if (onComplete) onComplete(path);\n    },\n    [bfs]\n  );\n\n  // Reset the state\n  const reset = useCallback(() => {\n    setExploredNodes([]);\n    setPath(null);\n    setIsProcessing(false);\n  }, []);\n\n  return {\n    exploredNodes,\n    path,\n    isProcessing,\n    startBFS,\n    reset,\n  };\n}\n\nexport default useBreadthFirstSearch;\n"
    }
  ],
  "type": "hooks:hook"
}